---
title: "bigRR"
output: 
  output: revealjs::revealjs_presentation:
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,cache = TRUE,autodep = TRUE)
```

```{r, include=FALSE}
library(bigRR)
library(ggplot2)
library(magrittr)
library(reshape2)
library(rrBLUP)
library(BGLR)
```

## get the data

Also center the genotpyes, so that the genotypes are represented as -1, 0, +1, as needed by some packages.

```{r, include=FALSE}
load("pheno.geno.Rdata")
geno.cols <- grep("^V",colnames(pheno.geno))
geno.center <- geno*2-1
head(geno.center[,1:10])
head(geno[,1:10])
all(row.names(geno.center) == row.names(pheno))
pheno <- as.data.frame(pheno)
```


## bigRR

Fit two bigRR models
```{r, include=FALSE}
bigRR1 <- bigRR(y=pheno$high.RFR,
                X = matrix(1,nrow = nrow(pheno),ncol=1), # intercepts
                Z = geno.center)
bigRR1.update <- bigRR_update(bigRR1,Z = geno.center) #this allows heteroscedatic shrinkage (stronger shrinkage on SNPs than others).
```

get BLUPs from the two models
```{r, include=FALSE}
snpBlups <- data.frame(bigRR=bigRR1$u, bigRR.HME=bigRR1.update$u,index=1:nrow(bigRR1$u)) %>% melt(id.vars="index",variable.name="model")
head(snpBlups)
summary(snpBlups)
```

compare BLUPs
```{r, include=FALSE}
snpBlups <- snpBlups[sample(nrow(snpBlups)),] #for a better plot, randomize the order of the observations
pl <- ggplot(snpBlups,aes(x=index,y=value,color=model))
pl <- pl + geom_point(size=.5,alpha=.5)
pl
pl + facet_wrap(~ model)
```

try some predictions...first, use half the data, and then try to predict the other half.
```{r, eval=FALSE,include=FALSE}
pheno.train <- pheno[1:100,]
pheno.test <- pheno[101:169,]
geno.train <- geno.center[1:100,]
geno.test <- geno.center[101:169,]

bigRR.train1 <- bigRR(y=pheno.train$high.RFR,
                X = matrix(1,nrow = nrow(pheno.train),ncol=1), # intercepts
                Z = geno.train)
bigRR1.train1.update <- bigRR_update(bigRR.train1,Z = geno.train) #this allows heteroscedatic shrinkage (stronger shrinkage on SNPs than others).
```

```{r, eval=FALSE, include=FALSE}
hyp.predict <- as.numeric(bigRR1.train1.update$beta + 
                            geno.test %*% bigRR1.train1.update$u)
plot(pheno.test$high.RFR,hyp.predict)
cor(pheno.test$high.RFR,hyp.predict)
```

Try again for larger training set
```{r, include=FALSE}
pheno.train.120 <- pheno[1:120,]
pheno.test.120 <- pheno[121:169,]
geno.train.120 <- geno.center[1:120,]
geno.test.120 <- geno.center[121:169,]
K.mat.train.120 <- K.mat[1:120,1:120]
bigRR.train1 <- bigRR(y=pheno.train.120$high.RFR,
                X = matrix(1,nrow = nrow(pheno.train.120),ncol=1), # intercepts
                Z = geno.train.120)
bigRR1.train1.update <- bigRR_update(bigRR.train1,Z = geno.train.120) #this allows heteroscedatic shrinkage (stronger shrinkage on SNPs than others).
```

```{r}
hyp.predict <- as.numeric(bigRR1.train1.update$beta + 
                            geno.test.120 %*% bigRR1.train1.update$u)
plot(pheno.test.120$high.RFR,hyp.predict)
cor(pheno.test.120$high.RFR,hyp.predict)
```

On to something else...

# rrBLUP

```{r, eval=FALSE, include=FALSE} 
# not needed for this analysis
impute <- A.mat(geno.center,max.missing = .5, impute.method = "mean", return.imputed = TRUE,n.core=3)
geno_impute <- impute$imputed
any(apply(geno_impute,2,function(x) any(is.na(x)))) #check for NAs.  If there are any, then would need to remove NA columns
```

fit model
```{r, include=FALSE}
rrBLUP1 <- mixed.solve(pheno.train$high.RFR, Z=geno.train)
names(rrBLUP1)
rrBLUP1$beta
head(rrBLUP1$u)
```

predict from model
```{r, include=FALSE}
prediction <- rrBLUP1$beta[1] + geno.test %*% as.matrix(rrBLUP1$u)
cor(pheno.test$high.RFR,prediction)
plot(pheno.test$high.RFR,prediction)
```

# BGLR

Fit a Bayesian Lasso model

```{r}
system.time(bglr.bl1 <- BGLR(y=pheno.train.120$high.RFR, 
                             ETA=list(list(X=geno.train.120,model="BL")),
                             verbose = FALSE,
                             saveAt = "bglr_output/bglr.bl1_",
                             niter=12000,burnIn = 2000))
```

Fit a Bayesian Lasso model, with K

```{r}
system.time(bglr.bl2 <- BGLR(y=pheno.train.120$high.RFR,
                             ETA=list(list(X=geno.train.120,model="BL"),
                                      list(K=K.mat.train.120,model="RKHS")),
                             verbose = FALSE,
                             saveAt = "bglr_output/bglr.bl2_",
                             niter=12000,burnIn = 2000))
```

Fit a BayesC model with

```{r}
system.time(bglr.bc1 <- BGLR(y=pheno.train.120$high.RFR, 
                             ETA=list(list(X=geno.train.120,model="BayesC")),
                             verbose = FALSE,
                             saveAt = "bglr_output/bglr.bc1_",
                             niter=12000,burnIn = 2000))
```

Fit a BayesC model with K
```{r}
system.time(bglr.bc2 <- BGLR(y=pheno.train.120$high.RFR,
                             ETA=list(list(X=geno.train.120,model="BayesC"),
                                      list(K=K.mat.train.120,model="RKHS")),
                             verbose = FALSE,
                             saveAt = "bglr_output/bglr.bc2_",
                             niter=12000,burnIn = 2000))
```

```{r, eval=FALSE}
#1# Estimated Marker Effects & posterior SDs
bHat <- bglr.bl1$ETA[[1]]$b
SD.bHat <- bglr.bl1$ETA[[1]]$SD.b
plot(bHat, ylab='Estimated Marker Effect',
type='p',cex=.5,col=4,main='Marker Effects')

#2# Predictions
  # Total prediction
yHat<-bglr.bl1$yHat
tmp<-range(c(pheno.train.120$high.RFR,yHat))
plot(yHat~pheno.train.120$high.RFR,xlab='Observed',ylab='Predicted',col=2,
            xlim=tmp,ylim=tmp); abline(a=0,b=1,col=4,lwd=2)

# predict for the test set
prediction <- geno.test.120 %*% bglr.bl1$ETA[[1]]$b + bglr.bl1$mu
plot(prediction~pheno.test.120$high.RFR,xlab='Observed',
ylab='Predicted',col=2)
cor(prediction,pheno.test.120$high.RFR)

#3# Goodness of fit and related statistics
   bglr.bl1$fit
   blgr.bl1$varE # compare to var(y)

#4# Trace plots
  list.files()
# Residual variance
varE<-scan('varE.dat') 
plot(varE,type='o',col=2,cex=.5,ylab=expression(var[e])); abline(h=bglr.bl1$varE,col=4,lwd=2); abline(v=bglr.bl1$burnIn/bglr.bl1$thin,col=4)
# lambda (regularization parameter of the Bayesian Lasso)
lambda<-scan('ETA_1_lambda.dat')
plot(lambda,type='o',col=2,cex=.5,ylab=expression(lambda)); abline(h=bglr.bl1$ETA[[1]]$lambda,col=4,lwd=2); abline(v=bglr.bl1$burnIn/bglr.bl1$thin,col=4)
```

